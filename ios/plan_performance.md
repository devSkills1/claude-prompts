# iOS 性能优化 / 卡顿治理 / 内存管理

> 适用于性能问题排查、优化方案设计、性能基线建立

【背景信息】
- App 类型（电商/社交/工具/游戏）：
- iOS 最低版本：
- 用户规模（DAU）：
- 问题场景描述：
- 影响用户比例：
- 复现条件（必现/高频/偶发）：
- 已接入监控工具（Instruments/MetricKit/Firebase/自建）：

【当前性能基线】（改动前的数据，用于对比）
- 启动性能：
  - 冷启动时间（main 之前 + main 之后）：
  - 热启动时间：
  - pre-main 耗时：
- 渲染性能：
  - 主要页面 FPS（滚动场景）：
  - 主线程卡顿率（> 16.67ms 占比）：
  - 掉帧次数/分钟：
- 内存性能：
  - 启动内存峰值：
  - 稳态内存：
  - 内存增长速率：
- 稳定性：
  - 崩溃率：
  - OOM 发生率：
  - ANR 率（Watchdog）：
- 其他：
  - 包体积：
  - CPU 使用率（前台/后台）：

【问题分类】（勾选适用项）
- [ ] **P0 - 严重影响可用性**
  - [ ] ANR（应用无响应 > 5s）
  - [ ] OOM（内存溢出闪退）
  - [ ] Watchdog 崩溃（启动超时）
  - [ ] 崩溃率 > 1%

- [ ] **P1 - 明显影响体验**
  - [ ] 冷启动 > 3s
  - [ ] 主线程卡顿（单次 > 100ms）
  - [ ] 滚动掉帧严重（FPS < 45）
  - [ ] 内存持续增长（内存泄漏）

- [ ] **P2 - 优化空间**
  - [ ] 启动时间可优化（1-3s）
  - [ ] 轻微掉帧（FPS 45-55）
  - [ ] 包体积偏大
  - [ ] 耗电量较高

【目标】（需量化，可验证）

P0（必须达成）：
- 示例：整体崩溃率 < 0.1%
- 示例：OOM 发生率 < 0.01%
- 示例：ANR 次数 = 0

P1（明确收益）：
- 示例：冷启动时间 < 2s（当前 3.5s）
- 示例：主线程卡顿率 < 1%（当前 5%）
- 示例：滚动 FPS >= 55（当前 40）

P2（可选优化）：
- 示例：内存峰值降低 20%
- 示例：包体积减少 10MB

【约束】
- 不改变业务逻辑
- 不改变 UI 行为和交互流程
- 不显著增加启动时间（< +50ms）
- 不增加内存峰值（< +10MB）
- 不使用私有 API（避免审核风险）
- 不破坏现有单元测试
- 最低支持 iOS 版本不变

【请输出】

1. **问题根因分析**（附数据支撑）
   - 使用 Instruments / Time Profiler / Allocations 定位瓶颈
   - 附调用栈 / 火焰图 / 内存快照分析
   - 量化各问题的性能影响（耗时/内存占用）

2. **主线程风险分类与优化**
   - 文件 I/O 阻塞（NSFileManager 同步操作）
   - 同步锁竞争（NSLock / @synchronized / semaphore）
   - RunLoop 过载（Timer / Observer 过多）
   - 大量 UI 布局计算（AutoLayout 复杂约束）
   - 主线程解码（图片 / JSON / Protobuf）
   - 数据库同步查询（SQLite / Core Data）

3. **启动优化方案**（如适用）
   - dyld 加载优化（减少动态库、合并 framework）
   - +load 方法治理（延迟或移除）
   - 首屏渲染优化（懒加载、占位图）
   - 启动任务分级（必要 / 可延迟 / 空闲时执行）
   - 网络请求优化（延迟非关键请求）

4. **渲染性能优化**（如适用）
   - 离屏渲染检测与优化
   - 图层混合优化（减少半透明视图）
   - 图片解码优化（预解码 / 缩略图）
   - 列表滚动优化（cell 复用 / 异步渲染）
   - AutoLayout 性能优化（减少约束复杂度）

5. **内存管理方案**（如适用）
   - 内存泄漏定位与修复
   - 大图加载策略（降采样 / 内存缓存上限）
   - 缓存策略优化（NSCache / LRU）
   - AutoreleasePool 使用优化
   - OOM 预警与内存释放机制

6. **常见错误用法列表**（附代码示例）
   - 错误写法 vs 正确写法对比
   - 每种错误的性能影响量化说明
   - 使用场景和替代方案

7. **防御式编程建议**
   - 线程安全保护（多线程访问共享资源）
   - 空值/越界防护（容器操作、数组访问）
   - 超时兜底机制（网络请求、异步任务）

8. **崩溃前保护策略**
   - OOM 预警与内存释放（didReceiveMemoryWarning）
   - Watchdog 超时规避（启动任务优化）
   - 异常捕获与恢复（NSException / Signal Handler）

9. **工具与监控方案**
   - 开发阶段：Instruments（Time Profiler / Allocations / Leaks）
   - 测试阶段：自动化性能测试 / 压力测试 / 基准测试
   - 线上监控：MetricKit / 自建 APM / Firebase Performance
   - 指标埋点：启动耗时 / FPS / 内存水位 / 崩溃堆栈

10. **每步验证方式**
    - 单元测试（性能基准测试）
    - Instruments 验证（对比优化前后）
    - 真机测试（低端机型 / 不同 iOS 版本）
    - 灰度发布（A/B 对照实验）

11. **回滚策略**
    - Git 分支策略（feature 分支 + 回滚 commit）
    - 功能开关控制（远程配置 / 灰度开关）
    - 性能劣化自动回滚阈值

12. **性能对比数据**（优化前 vs 优化后）
    | 指标 | 优化前 | 优化后 | 提升幅度 |
    |------|--------|--------|----------|
    | 冷启动 | Xs | Xs | -X% |
    | FPS | X | X | +X% |
    | 内存峰值 | XMB | XMB | -X% |

【禁止】
- 猜测性优化（无数据支撑的优化）
- 过早优化（优化非瓶颈代码）
- 过度优化（引入复杂度换取微小提升）
- 牺牲可读性（难以维护的优化代码）
- 使用私有 API（影响审核）

【规则】
- 只分析，不写代码
- 数据驱动，有理有据
- 每步可验证、可回滚
- 偏保守方案优先
- 优化需量化收益

【相关文档】
- 审计时对照：`checklist.md` 性能部分（第 7-11 节）
- 执行时使用：`code_execute_step.md`
- 审核时使用：`review_and_rollback.md`

---
只给方案，不写代码